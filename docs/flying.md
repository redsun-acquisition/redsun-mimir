# Implementing Flyable Devices with Stream Assets

This guide describes how to implement devices that support bluesky's flying scan pattern with stream assets, allowing continuous data acquisition to disk while maintaining live visualization.

> Note that this guide has been autogenerated by Claude after a cycle of rinse-and-repeat optimizations in the context of this application. A better, more comprehensive documentation on the design decisions of Bluesky flyer interface will be provided when possible.

## Overview

A **flyable device with stream assets** implements the `ReadableFlyer` protocol, which combines:
- **`Readable`**: Provides live data readings for visualization
- **`Flyable`**: Supports background data acquisition (kickoff/complete)
- **`Preparable`**: Allows configuration before acquisition
- **`Collectable`**: Describes collected data structure
- **`WritesStreamAssets`**: Emits metadata about data written to external storage

## Protocol Requirements

### 1. Core Protocols

```python
class MyCamera(Readable, Flyable, Preparable, Collectable, WritesStreamAssets):
    def read(self) -> dict[str, Reading]:
        """Return current frame for live visualization."""

    def describe(self) -> dict[str, DataKey]:
        """Describe the data returned by read()."""

    def prepare(self, **kwargs) -> Status:
        """Configure the device before acquisition (e.g., set up storage)."""

    def kickoff(self) -> Status:
        """Start background data acquisition."""

    def complete(self) -> Status:
        """Stop background acquisition and finalize."""

    def describe_collect(self) -> dict[str, DataKey]:
        """Describe the collected data structure."""

    def collect_asset_docs(self, index: int | None = None) -> Iterator[StreamAsset]:
        """Emit metadata about data written to external storage."""

    def get_index(self) -> int:
        """Return the current number of frames written."""
```

### Method Responsibilities

#### `read()` - Provide Current Data Snapshot

**Purpose**: Return the device's current state as a dictionary of readings. This is called during `trigger_and_read()` for live visualization or monitoring.

**Behavior**:
- Should return quickly (typically < 100ms)
- When flying: return data from internal buffer (not from disk)
- When not flying: return data directly from hardware
- Each call should return the "current" state, which may or may not be a new frame
- Return format: `{data_key: {"value": actual_data, "timestamp": unix_timestamp}}`

**Contract**: Must match the data keys declared in `describe()`. The RunEngine uses this to populate Event documents that go to subscribers for live plotting, monitoring, etc.

**Example Use**: During live acquisition, the RunEngine repeatedly calls `read()` to get frames for display in a GUI, without waiting for the entire acquisition to finish.

---

#### `describe()` - Declare Live Data Structure

**Purpose**: Provide metadata about what `read()` returns. This tells the RunEngine what data keys to expect, their types, shapes, and sources.

**Behavior**:
- Called once when a stream is first created
- Result is cached by RunEngine to create Event Descriptor documents
- **Critical**: Should NOT include `external: "STREAM:"` keys for flyable devices
- Defines the schema for live data only, not collected assets

**Contract**: The keys in `describe()` must exactly match the keys returned by `read()`. The metadata describes properties that don't change during a run (dtype, shape, units, etc.).

**Why Separate from Assets**: By excluding stream assets from `describe()`, you tell bluesky that `read()` provides direct data values, not references to external files. This prevents bluesky from calling `collect_asset_docs()` during every `trigger_and_read()`.

---

#### `prepare(**kwargs)` - Set Up Before Acquisition

**Purpose**: Configure the device for an upcoming acquisition. This is where you allocate resources, set up storage backends, and initialize state.

**Behavior**:
- Called before `kickoff()` to set up the acquisition
- Receives keyword arguments specifying acquisition parameters (file path, number of frames, etc.)
- Should create/open storage files, allocate buffers, configure hardware
- Must reset collection state: counters, UIDs, flags
- Should NOT start acquiring data yet (that's `kickoff()`'s job)
- Returns a Status object that completes when preparation is done

**Contract**: After `prepare()` succeeds, the device must be ready for `kickoff()` to start acquisition immediately. The device should be in a "armed and ready" state.

**Why Separate from `kickoff()`**: Preparation can be time-consuming (opening files, allocating memory). By separating it, the RunEngine can prepare multiple devices in parallel, then kickoff all at once for synchronized starts.

---

#### `kickoff()` - Start Background Acquisition

**Purpose**: Begin the background data acquisition process. This signals the device to start collecting and writing data.

**Behavior**:
- Called after `prepare()` has succeeded
- Should start background thread/task that acquires and writes data
- Returns immediately (doesn't wait for acquisition to finish)
- Sets internal `_isflying=True` flag
- Returns a Status that completes when acquisition has *started* (not finished)

**Contract**: After `kickoff()` returns, the device should be actively acquiring data in the background. Subsequent `read()` calls should return data from the ongoing acquisition. The device remains in flying state until `complete()` is called.

**Timing**: The Status returned by `kickoff()` should complete quickly (when acquisition starts), not when it finishes. The RunEngine may kickoff multiple devices and needs to know they all started successfully.

---

#### `complete()` - Stop and Finalize Acquisition

**Purpose**: Signal the device to stop acquiring data and finalize any resources (close files, flush buffers).

**Behavior**:
- Called after `kickoff()` when acquisition should stop
- For fixed-frame acquisitions: may block until all frames are written
- For continuous acquisitions: signals the background thread to stop
- Waits for background thread to finish and join
- Closes/finalizes storage files
- Sets `_isflying=False` (now safe to emit stream assets)
- Returns a Status that completes when finalization is done

**Contract**: After `complete()` succeeds, the device is no longer acquiring data. All data has been written to storage and files are closed. The device should be ready for `collect_asset_docs()` to report what was written.

**Status Semantics**: Unlike `kickoff()`, the Status from `complete()` should not finish until the device has fully stopped and finalized. The RunEngine uses this to know when it's safe to collect assets.

---

#### `describe_collect()` - Declare Collected Asset Structure

**Purpose**: Describe the data that will be collected and written to external storage. This is separate from `describe()` because collected data may have different characteristics than live reads.

**Behavior**:
- Returns metadata about data written to disk during flying
- **Must** include `external: "STREAM:"` for data keys backed by external files
- Shape can include `None` for unlimited dimensions (e.g., `[None, height, width]`)
- Called by RunEngine to create descriptors for collect streams

**Contract**: The data keys in `describe_collect()` must match the `data_key` fields in StreamResource documents emitted by `collect_asset_docs()`. This links the stream descriptor to the actual data files.

**Why Different from `describe()`**: Live reads may return single frames or downsampled data for visualization, while collected assets are the full, high-resolution dataset on disk. The metadata reflects these differences.

---

#### `collect_asset_docs(index)` - Report Written Data

**Purpose**: Emit metadata documents that tell the data management system where to find the data written during flying, and which frames were written.

**Behavior**:
- Called explicitly via `bps.collect()` or automatically during `backstop_collect()`
- Should check guards: don't emit if `_frames_written == 0` or `_isflying == True`
- Emits two types of documents:
  1. **StreamResource** (once): Points to the data file (path, format, parameters)
  2. **StreamDatum** (each call): Specifies frame range written (indices)
- Uses persistent `_stream_resource_uid` to link datum to resource
- Tracks `_collection_counter` to report incremental frame ranges
- Returns empty if called during flying (prevents wrong-stream emission)

**Contract**:
- StreamResource must have a unique UID, used consistently across all datums
- StreamDatum indices must be incremental: first call `{0, 10}`, second call `{10, 25}`, etc.
- The `descriptor` and `seq_nums` fields must be empty strings/zeros - RunEngine fills these
- The `data_key` must match a key from `describe_collect()` with `external: "STREAM:"`

**Incremental Reporting**: If called multiple times (e.g., during long acquisition), each call should report only *new* frames since last call, not all frames from the beginning.

**The Flying Guard**: The `_isflying` check is critical. During flying, `read()` is called for live visualization. If the device implements `WritesStreamAssets`, bluesky will call `collect_asset_docs()` after each read. By returning empty during flying, you prevent assets from being emitted into the live stream (which doesn't have the proper descriptors for them).

---

#### `get_index()` - Report Current Progress

**Purpose**: Return how many frames have been written so far. Used for synchronizing multiple devices in a collect operation.

**Behavior**:
- Simply returns `self._frames_written`
- Can be called at any time, including during flying
- Used by RunEngine when collecting from multiple devices to find common frame range

**Contract**: Must return a non-negative integer representing the current write position. Should be thread-safe as it may be called while background thread is writing.

**Multi-Device Sync**: When `bps.collect()` is called with multiple devices, the RunEngine calls `get_index()` on each, takes the minimum, and passes that as the `index` argument to `collect_asset_docs()`. This ensures all devices report the same frame range, keeping them synchronized.

## Key Implementation Details

### State Tracking

Track the device state to control when stream assets are emitted:

```python
def __init__(self, ...):
    # Flying state flag - controls asset emission
    self._isflying = False

    # Total frames written to disk during current acquisition
    self._frames_written = 0

    # Frames already reported via collect_asset_docs (for incremental reporting)
    self._collection_counter = 0

    # Persistent UID for current acquisition (generated in prepare())
    self._stream_resource_uid = ""
```

**Why These Variables Matter**:

- **`_isflying`**: The critical guard that prevents stream assets from being emitted during live reads. When `True`, `collect_asset_docs()` returns empty. Set to `True` in `kickoff()`, `False` in `complete()`.

- **`_frames_written`**: Tracks the actual progress of background data writing. Updated by the background thread each time a frame is written. Used in `get_index()` and `collect_asset_docs()`.

- **`_collection_counter`**: Remembers how many frames were already reported in previous `collect_asset_docs()` calls. Enables incremental reporting: first call reports frames 0-10, second call reports 10-25, etc. Reset to 0 in `prepare()`.

- **`_stream_resource_uid`**: The unique identifier for the StreamResource document. Must remain constant throughout an acquisition session so all StreamDatum documents can reference it. Generated once in `prepare()`, used in all `collect_asset_docs()` calls.

### Separate `describe()` from Stream Assets

**Critical**: `describe()` should **NOT** include `external: "STREAM:"` keys. This tells bluesky to only call `collect_asset_docs()` during explicit collection, not during every `trigger_and_read()`.

**The Problem**: If you include stream asset keys in `describe()`, bluesky treats the device as a "Readable that produces external data". This means during every `trigger_and_read()` for live visualization, bluesky will:
1. Call `read()` to get data
2. Call `collect_asset_docs()` to get asset metadata
3. Try to emit both to the same stream

But during flying, you want:
- Live reads → go to "live" stream (for visualization)
- Asset metadata → go to separate "stream" stream (only after complete)

**The Solution**: Keep them separate:

```python
def describe(self) -> dict[str, DataKey]:
    """Describe live data only - no stream assets.

    This is called to create descriptors for the live visualization stream.
    By omitting external: "STREAM:" keys, we tell bluesky this device
    returns actual data values in read(), not file references.
    """
    return {
        f"{self.name}:image": {
            "source": "camera",
            "dtype": "array",
            "shape": [height, width],
        },
        # NO external: "STREAM:" key here!
        # This prevents collect_asset_docs() being called during trigger_and_read()
    }

def describe_collect(self) -> dict[str, DataKey]:
    """Describe collected stream data.

    This is called to create descriptors for the stream that will receive
    asset documents. It's only used when declare_stream(collect=True) or
    explicit collect() is called.
    """
    return {
        f"{self.name}:stream": {
            "source": "file",
            "dtype": "array",
            "shape": [None, height, width],  # None = unlimited frames
            "external": "STREAM:",            # This IS a stream asset!
        }
    }
```

**Key Insight**: The same physical data (frames from camera) is described twice:
- In `describe()`: as live array data for visualization
- In `describe_collect()`: as external stream asset for permanent storage

This dual representation allows the device to provide both real-time feedback and permanent archival in a single acquisition.

### The `collect_asset_docs()` Pattern

This method must:
1. **Only emit when not flying** - prevents assets going to wrong stream
2. **Emit StreamResource once** - on first call only
3. **Emit StreamDatum with incremental indices** - tracks frame ranges
4. **Return empty if nothing to report** - handles repeated calls

```python
def collect_asset_docs(self, index: int | None = None) -> Iterator[StreamAsset]:
    """Emit metadata about data written to external storage.

    Called by:
    - Explicit bps.collect() in your plan
    - backstop_collect() when run ends

    Should NOT emit during live reads (trigger_and_read).
    """
    # Guard: don't emit if no data or still flying
    if self._frames_written == 0 or self._isflying:
        return

    # Determine how many frames to report
    frames_to_report = index if index is not None else self._frames_written

    # Don't re-emit already reported frames
    if self._collection_counter >= frames_to_report:
        return

    # Emit StreamResource only on first call
    if self._collection_counter == 0:
        stream_resource: StreamResource = {
            "data_key": f"{self.name}:stream",
            "mimetype": "application/x-hdf5",  # or your format
            "parameters": {},
            "uid": self._stream_resource_uid,
            "uri": str(self._storage_path),
        }
        yield ("stream_resource", stream_resource)

    # Always emit StreamDatum with incremental indices
    stream_datum: StreamDatum = {
        "descriptor": "",  # RunEngine fills this
        "indices": {"start": self._collection_counter, "stop": frames_to_report},
        "seq_nums": {"start": 0, "stop": 0},  # RunEngine fills this
        "stream_resource": self._stream_resource_uid,
        "uid": f"{self._stream_resource_uid}/{self._collection_counter}",
    }
    yield ("stream_datum", stream_datum)

    # Update counter
    self._collection_counter = frames_to_report
```

### The Prepare-Kickoff-Complete Lifecycle

```python
def prepare(self, store_path: Path, capacity: int, **kwargs) -> Status:
    """Set up storage backend before acquisition."""
    s = Status()
    try:
        # Set up your storage (HDF5, Zarr, etc.)
        self._setup_storage(store_path, capacity)

        # Reset state for new acquisition
        self._collection_counter = 0
        self._stream_resource_uid = str(uuid.uuid4())
        self._frames_written = 0

        # Start background thread (but don't start writing yet)
        self._start_background_thread()

        s.set_finished()
    except Exception as e:
        s.set_exception(e)
    return s

def kickoff(self) -> Status:
    """Start background data acquisition."""
    s = Status()
    if not self._thread:
        s.set_exception(RuntimeError("Call prepare() first"))
        return s

    self._isflying = True
    self._start_writing_signal.set()  # Signal thread to start writing
    s.set_finished()
    return s

def complete(self) -> Status:
    """Stop acquisition and finalize storage."""
    s = Status()
    if not self._isflying:
        s.set_exception(RuntimeError("Not flying; call kickoff() first"))
        return s

    self._stop_writing_signal.set()  # Signal thread to stop
    self._thread.join()               # Wait for thread to finish
    self._isflying = False            # Now safe to emit assets
    self._close_storage()             # Finalize file

    s.set_finished()
    return s
```

## Reading While Flying: The Internal Buffer Pattern

To support **live visualization during background acquisition**, you need an internal buffer.

### Why?

- **Background thread**: Continuously grabs frames and writes to disk
- **Live reads**: `trigger_and_read()` needs current frame for visualization
- **Problem**: Can't return frames from disk (too slow)
- **Solution**: Ring buffer that holds the most recent frame(s)

### Implementation

```python
from redsun_mimir.model.utils import RingBuffer

def prepare(self, ...):
    # Create small ring buffer (1-2 frames sufficient)
    self._read_buffer = RingBuffer(
        max_capacity=1,
        dtype=(self._dtype, (height, width))
    )

def _background_acquisition_thread(self):
    """Background thread that writes to disk."""
    self._start_writing_signal.wait()

    while not self._stop_writing_signal.is_set():
        # Grab frame from hardware
        frame = self._hardware.get_next_frame()

        # Write to disk
        self._storage.write(frame)
        self._frames_written += 1

        # Also put in buffer for live reads
        self._read_buffer.append(frame)

def read(self) -> dict[str, Reading]:
    """Return current frame for live visualization."""
    if self._isflying:
        # During flying: peek at buffer (don't consume)
        frame = self._read_buffer.peek()
    else:
        # Normal read: get directly from hardware
        frame = self._hardware.get_next_frame()

    return {
        f"{self.name}:image": {
            "value": frame,
            "timestamp": time.time(),
        }
    }
```

### Buffer Size Considerations

- **1 frame**: Sufficient for most cases, minimal memory
- **2+ frames**: Useful if read rate doesn't match acquisition rate
- **Ring buffer**: Automatically overwrites old frames, prevents memory growth

## Plan Integration

### Basic Flying Scan

```python
def fly_and_collect(detector, store_path, frames):
    yield from bps.open_run()
    yield from bps.stage(detector)

    # Prepare storage
    yield from bps.prepare(detector, store_path=store_path, capacity=frames)

    # Start background acquisition
    yield from bps.kickoff(detector, wait=True)

    # Wait for completion
    yield from bps.complete(detector, wait=True)

    # Collect stream assets
    yield from bps.collect(detector, name="stream")

    yield from bps.unstage(detector)
    yield from bps.close_run()
```

### Live Visualization + Flying

```python
def live_with_streaming(detector, store_path):
    live_stream = "live"

    yield from bps.open_run()
    yield from bps.stage(detector)

    while True:
        # Live reads go to "live" stream (no assets)
        yield from bps.trigger_and_read([detector], name=live_stream)

        # When user triggers streaming:
        if user_triggered_streaming:
            # Declare stream for assets
            yield from bps.declare_stream(detector, name="stream", collect=True)

            # Prepare and start
            yield from bps.prepare(detector, store_path=store_path, capacity=100)
            yield from bps.kickoff(detector, wait=True)

            # Continue live reads during acquisition
            while not streaming_complete:
                yield from bps.trigger_and_read([detector], name=live_stream)

            # Stop and collect
            yield from bps.complete(detector, wait=True)
            yield from bps.collect(detector, name="stream")
```

## Multiple Streaming Sessions

Each streaming session should write to a **unique file** to avoid conflicts:

```python
# Create unique path per session
timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
acquisition_path = base_path / f"{timestamp}.zarr"

# Each prepare() call resets state
yield from bps.prepare(detector, store_path=acquisition_path, ...)
```

This allows:
- Multiple trigger/stop cycles in one run
- Each session gets its own StreamResource
- No data corruption from overlapping writes

## Common Pitfalls

### ❌ Don't: Include `external: "STREAM:"` in `describe()`

This causes bluesky to call `collect_asset_docs()` during every `trigger_and_read()`, expecting single-frame assets.

### ❌ Don't: Emit assets while flying

Check `_isflying` in `collect_asset_docs()` to prevent emitting into wrong stream.

### ❌ Don't: Generate new UIDs on every `collect_asset_docs()` call

Use a persistent `_stream_resource_uid` generated in `prepare()`.

### ❌ Don't: Always start indices at 0

Track `_collection_counter` for incremental indices across multiple calls.

### ✅ Do: Reset state in `prepare()`

Each acquisition should start fresh with `_collection_counter = 0` and new UID.

### ✅ Do: Use small ring buffers

1-2 frames is sufficient for live reads during flying.

### ✅ Do: Separate live stream from asset stream

Use different stream names: "live" for visualization, "stream" for assets.

## Summary

A compliant `ReadableFlyer` with stream assets:

1. **Separates concerns**: `describe()` for live data, `describe_collect()` for assets
2. **Tracks state**: Uses `_isflying` to control when assets are emitted
3. **Emits correctly**: StreamResource once, StreamDatum with incremental indices
4. **Buffers frames**: Small ring buffer enables reading while flying
5. **Resets per session**: Each `prepare()` creates fresh acquisition state
6. **Integrates with plans**: Works with explicit `collect()` or backstop collection

This pattern allows seamless integration of continuous data acquisition with bluesky's event model, providing both live visualization and permanent storage with proper metadata.
