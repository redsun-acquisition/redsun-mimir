from __future__ import annotations

from collections.abc import Mapping, Sequence  # noqa: TC003
from threading import Event
from typing import TYPE_CHECKING

import bluesky.plan_stubs as bps
import in_n_out as ino
from bluesky.utils import MsgGenerator  # noqa: TC002
from sunflare.controller import ControllerProtocol
from sunflare.engine import RunEngine
from sunflare.log import Loggable
from sunflare.virtual import Signal, VirtualBus

from redsun_mimir.common import (
    PlanSpec,
    create_plan_spec,
    interrupts,
)
from redsun_mimir.common import (
    plan_stubs as sps,
)
from redsun_mimir.protocols import DetectorProtocol, MotorProtocol
from redsun_mimir.utils import filter_models, get_choice_list

if TYPE_CHECKING:
    from concurrent.futures import Future
    from typing import Any, Callable, Mapping

    from sunflare.model import ModelProtocol

    from ._config import AcquisitionControllerInfo, RendererControllerInfo

store = ino.Store.create("plan_specs")


class AcquisitionController(ControllerProtocol, Loggable):
    """A centralized acquisition controller to manage a Bluesky run engine.

    Parameters
    ----------
    ctrl_info : ``AcquisitionControllerInfo``
        The acquisition controller configuration information.
    models : ``Mapping[str, ModelProtocol]``
        The available models in the application.
    virtual_bus : ``VirtualBus``
        The virtual bus to register signals on.

    Attributes
    ----------
    sigPlanDone : ``Signal``
        Signal emitted when a plan is done.
    sigNewDocument : ``Signal(str, Document)``
        Signal emitted when a new document is generated by the run engine.
        - str: The name of the document ("start", "stop", "event", "descriptor").
        - Document: The document data.
    """

    sigPlanDone = Signal()
    sigNewDocument = Signal(str, object)

    def __init__(
        self,
        ctrl_info: AcquisitionControllerInfo,
        models: Mapping[str, ModelProtocol],
        virtual_bus: VirtualBus,
    ) -> None:
        self.ctrl_info = ctrl_info
        self.virtual_bus = virtual_bus
        self.models = models
        self.live_event = Event()
        self.engine = RunEngine()
        self.event_manager = interrupts.EventManager()

        self.futures: set[Future[Any]] = set()

        self.plans: dict[str, Callable[..., MsgGenerator[Any]]] = {
            "live_count": self.live_count,
            "snap": self.snap,
        }
        self.plan_specs: set[PlanSpec] = {
            create_plan_spec(plan, models) for plan in self.plans.values()
        }

        store.register_provider(self.plans_specificiers)

    def registration_phase(self) -> None:
        self.virtual_bus.register_signals(self)

    def connection_phase(self) -> None:
        self.virtual_bus["AcquisitionWidget"]["sigLaunchPlanRequest"].connect(
            self.launch_plan
        )
        self.virtual_bus["AcquisitionWidget"]["sigStopPlanRequest"].connect(
            self.stop_plan
        )

    def plans_specificiers(self) -> set[PlanSpec]:
        return self.plan_specs

    def live_count(
        self, detectors: Sequence[DetectorProtocol], /, events: Sequence[str] = ["stop"]
    ) -> MsgGenerator[None]:
        """Start a live acquisition with the selected detectors.

        Parameters
        ----------
        detectors : ``Sequence[DetectorProtocol]``
            The detectors to use in the live acquisition.
        """
        self.logger.debug("Starting live count acquisition.")

        event_map = interrupts.create(events, self.event_manager)

        yield from bps.open_run()
        yield from bps.stage_all(*detectors)

        # TODO: DetectorProtocol should inherit from Flyable but it doesn't;
        # needs to be fixed in sunflare package
        yield from sps.collect_while_waiting(detectors, event_map, stream_name="live")  # type: ignore[arg-type]
        yield from bps.unstage_all(*detectors)
        yield from bps.close_run(exit_status="success")
        self.logger.debug("Live count acquisition stopped.")

    def snap(
        self, detectors: Sequence[DetectorProtocol], frames: int = 1
    ) -> MsgGenerator[None]:
        """Take ``num_frames`` snapshot from each detector.

        Parameters
        ----------
        detectors : ``Sequence[DetectorProtocol]``
            The detectors to take a snapshot from.
        num_frames : ``int``, optional
            The number of snapshots to take for each detector.
            Must be a non-zero, positive integer.
            Default is 1.
        """
        if frames <= 0:
            raise ValueError("Number of frames must be a positive integer.")

        self.logger.debug(f"Taking {frames} frame(s).")
        yield from bps.open_run()
        yield from bps.stage_all(*detectors)
        for _ in range(frames):
            yield from bps.trigger_and_read(detectors, name="snap")
        yield from bps.unstage_all(*detectors)
        yield from bps.close_run(exit_status="success")
        self.logger.debug("Snapshot done.")

    def __call__(self, plan_name: str, kwargs: dict[str, Any]) -> None:
        self.launch_plan(plan_name, togglable=False, kwargs=kwargs)

    def launch_plan(
        self, plan_name: str, togglable: bool, kwargs: dict[str, Any]
    ) -> None:
        """Launch the specified plan.

        Parameters
        ----------
        plan_name : ``str``
            The name of the plan to launch.
        togglable : ``bool``
            Whether the plan is togglable.
        kwargs : ``dict[str, Any]``
            Keyword arguments to pass to the plan.
        """
        plan = self.plans[plan_name]
        for name, arg in kwargs.items():
            if type(arg) is tuple and len(arg) == 2:
                # view packs the annotation and value in a tuple
                # for models; unpack it and update the kwargs
                # with the actual models
                choices = get_choice_list(self.models, arg[0], arg[1])
                kwargs[name] = choices
        if togglable:
            # TODO: this imposes the constraint that
            # plans always have to refer to the local
            # live_event obj; maybe it should be
            # passed as an argument to the plan?
            self.live_event.set()
        fut = self.engine(plan(**kwargs))
        self.futures.add(fut)

        # TODO: add a specific callback that emits
        # a possible result object from the future,
        # and it also discards the future from the set
        fut.add_done_callback(self.futures.discard)

    def stop_plan(self) -> None:
        """Stop the running plan."""
        if self.live_event.is_set():
            self.live_event.clear()
            self.logger.debug("Stopping live plan.")
        else:
            self.engine.stop()


class MedianAcquisitionController(ControllerProtocol, Loggable):
    def __init__(
        self,
        ctrl_info: RendererControllerInfo,
        models: Mapping[str, ModelProtocol],
        virtual_bus: VirtualBus,
    ) -> None:
        self.virtual_bus = virtual_bus
        self.ctrl_info = ctrl_info
        self.detectors = filter_models(models, DetectorProtocol)
        self.motors = filter_models(models, MotorProtocol)

    def registration_phase(self) -> None: ...

    def connection_phase(self) -> None: ...
