from __future__ import annotations

from collections.abc import Mapping, Sequence  # noqa: TC003
from typing import TYPE_CHECKING

import bluesky.plan_stubs as bps
import in_n_out as ino
from bluesky.utils import MsgGenerator  # noqa: TC002
from sunflare.engine import RunEngine
from sunflare.log import Loggable
from sunflare.presenter import PPresenter
from sunflare.virtual import Signal, VirtualBus

from redsun_mimir.common import (
    PlanSpec,
    collect_arguments,
    create_plan_spec,
)
from redsun_mimir.common.actions import Actions, actioned
from redsun_mimir.protocols import DetectorProtocol  # noqa: TC001
from redsun_mimir.utils import get_choice_list, issequence

if TYPE_CHECKING:
    from concurrent.futures import Future
    from typing import Any, Callable, Mapping

    from event_model.documents import Document
    from sunflare.model import PModel

    from ._config import AcquisitionControllerInfo

store = ino.Store.create("plan_specs")


class AcquisitionController(PPresenter, Loggable):
    """A centralized acquisition presenter to manage a Bluesky run engine.

    Parameters
    ----------
    ctrl_info : ``AcquisitionControllerInfo``
        The acquisition presenter configuration information.
    models : ``Mapping[str, PModel]``
        The available models in the application.
    virtual_bus : ``VirtualBus``
        The virtual bus to register signals on.

    Attributes
    ----------
    sigPlanDone : ``Signal``
        Signal emitted when a plan is done.
    sigNewDocument : ``Signal(str, Document)``
        Signal emitted when a new document is generated by the run engine.
        - str: The name of the document ("start", "stop", "event", "descriptor").
        - Document: The document data.
    """

    sigPlanDone = Signal()
    sigNewDocument = Signal(str, object)
    log_token: int
    sig_token: int

    def __init__(
        self,
        ctrl_info: AcquisitionControllerInfo,
        models: Mapping[str, PModel],
        virtual_bus: VirtualBus,
    ) -> None:
        self.ctrl_info = ctrl_info
        self.virtual_bus = virtual_bus
        self.models = models
        self.engine = RunEngine()
        if ctrl_info.debug:
            self.log_token = self.engine.subscribe(self.log_document_type)
        self.sig_token = self.engine.subscribe(self.sigNewDocument.emit)

        self.futures: set[Future[Any]] = set()
        self.discard_by_pause = False

        self.plans: dict[str, Callable[..., MsgGenerator[Any]]] = {
            "live_count": self.live_count,
            "snap": self.snap,
        }
        self.plan_specs: dict[str, PlanSpec] = {
            name: create_plan_spec(plan, models) for name, plan in self.plans.items()
        }

        store.register_provider(self.plans_specificiers)

    def registration_phase(self) -> None:
        self.virtual_bus.register_signals(self)

    def connection_phase(self) -> None:
        self.virtual_bus["AcquisitionWidget"]["sigLaunchPlanRequest"].connect(
            self.launch_plan
        )
        self.virtual_bus["AcquisitionWidget"]["sigStopPlanRequest"].connect(
            self.stop_plan
        )
        self.virtual_bus["AcquisitionWidget"]["sigPauseResumeRequest"].connect(
            self.pause_or_resume_plan
        )

    def plans_specificiers(self) -> set[PlanSpec]:
        return set(self.plan_specs.values())

    @actioned(togglable=True, pausable=True)
    def live_count(
        self,
        detectors: Sequence[DetectorProtocol],
    ) -> MsgGenerator[None]:
        """Start a live acquisition with the selected detectors.

        Parameters
        ----------
        - detectors : ``Sequence[DetectorProtocol]``
            - The detectors to use in the live acquisition.
        """
        yield from bps.open_run()
        yield from bps.stage_all(*detectors)

        while True:
            # keep a checkpoint in case of pause/resume
            yield from bps.checkpoint()
            yield from bps.trigger_and_read(detectors, name="live_count")

    def snap(
        self, detectors: Sequence[DetectorProtocol], frames: int = 1
    ) -> MsgGenerator[None]:
        """Take ``frames`` number snapshot from each detector.

        Parameters
        ----------
        - detectors : ``Sequence[DetectorProtocol]``
            - The detectors to take a snapshot from.
        - frames : ``int``, optional
            - The number of snapshots to take for each detector.
            Must be a non-zero, positive integer.
            Default is 1.
        """
        if frames <= 0:
            # safeguard against invalid input
            frames = 1

        yield from bps.open_run()
        yield from bps.stage_all(*detectors)
        for _ in range(frames):
            yield from bps.trigger_and_read(detectors, name="snap")
        yield from bps.unstage_all(*detectors)
        yield from bps.close_run(exit_status="success")

    def launch_plan(self, plan_name: str, param_values: Mapping[str, Any]) -> None:
        """Launch the specified plan.

        Parameters
        ----------
        plan_name : ``str``
            The name of the plan to launch.
        param_values : ``Mapping[str, Any]``
            The parameter values to pass to the plan.
            Elaborated from the UI inputs.
        """
        if (
            plan_name not in self.plans.keys()
            or plan_name not in self.plan_specs.keys()
        ):
            return

        plan = self.plans[plan_name]
        spec = self.plan_specs[plan_name]

        # start with values coming from the view
        values: dict[str, Any] = dict(param_values)

        # For Actions-typed parameters that have metadata but no GUI input,
        # inject the Actions instance so the function can always be called.
        for p in spec.parameters:
            if (
                p.annotation is Actions
                and p.actions is not None
                and p.name not in values
            ):
                values[p.name] = p.actions

        resolved: dict[str, Any] = {}

        # For Actions-typed parameters that have metadata but no GUI input,
        # inject the Actions instance so the function can always be called.
        for p in spec.parameters:
            if p.name not in values:
                continue
            val = values[p.name]
            models: list[PModel] = []

            # Model-backed parameter: indicated by presence of choices
            if p.choices is not None:
                # Coerce widget value into a list of string labels
                if isinstance(val, str):
                    labels = [val]
                elif isinstance(val, Sequence) and not isinstance(val, (str, bytes)):
                    labels = [str(v) for v in val]
                else:
                    labels = [str(val)]
                proto: type[PModel] | None = p.model_proto
                if proto:
                    models = get_choice_list(self.models, proto, labels)

                if p.kind.name == "VAR_POSITIONAL" or issequence(p.annotation):
                    # Sequence[...] or *detectors → pass the list as-is
                    resolved[p.name] = models
                else:
                    # Single model parameter → first match or None
                    resolved[p.name] = models[0] if models else None
            else:
                # Non-model parameter (or no registry): pass through
                resolved[p.name] = val

        args, kwargs = collect_arguments(spec, resolved)
        fut = self.engine(plan(*args, **kwargs))
        self.futures.add(fut)

        if not spec.togglable:
            # Single-shot plan: emit done when finished
            fut.add_done_callback(lambda f: self.sigPlanDone.emit())

        fut.add_done_callback(self._discard_future)

    def pause_or_resume_plan(self, pause: bool) -> None:
        """Pause or resume the running plan.

        Parameters
        ----------
        pause : ``bool``
            If True, pause the plan; if False, resume the plan.
        """
        if pause:
            self.discard_by_pause = True
            self.engine.request_pause(defer=True)
        else:
            # when resuming, the previous
            # future has beend discarded;
            # we store the new future again
            fut = self.engine.resume()
            self.futures.add(fut)
            fut.add_done_callback(self._discard_future)

    def stop_plan(self) -> None:
        """Stop the running plan."""
        self.engine.stop()

    def log_document_type(self, name: str, doc: Document) -> None:
        """Log the document nama and type for debugging.

        Parameters
        ----------
        name : ``str``
            The name of the document ("start", "stop", "event", "descriptor").
        doc : ``Document``
            The document data (unused).
        """
        self.logger.debug(f"New document: {name}")

    def _discard_future(self, fut: Future[Any]) -> None:
        # TODO: consider emitting a result
        # if the plan was not paused
        # and it also discards the future from the set
        if self.discard_by_pause:
            self.discard_by_pause = False
        self.futures.discard(fut)
